<!--
    Copyright Â© 2024 AO Kaspersky Lab.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->

<xsl:transform xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
               xmlns:system="clr-namespace:System;assembly=mscorlib"
               xmlns:msxsl="urn:schemas-microsoft-com:xslt"
               xmlns:uikit="http://schemas.kaspirin.com/common/uikit"
               xmlns:visuals="http://schemas.kaspirin.com/common/visuals"
               xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
               xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
               exclude-result-prefixes="msxsl"
               version="1.0">

	<xsl:template name="getAutogeneratedComment">
		<xsl:param name="source" />
		<xsl:param name="comment" />

		<xsl:comment xml:space="preserve">  <xsl:value-of select="$comment"/>  </xsl:comment>

	</xsl:template>

	<xsl:template name="getRegionComment">
		<xsl:param name="description" />

		<xsl:comment xml:space="preserve">#region <xsl:value-of select="$description"/></xsl:comment>
	</xsl:template>

	<xsl:template name="getEndRegionComment">
		<xsl:comment>#endregion</xsl:comment>
	</xsl:template>

	<xsl:template name="getIdComment">
		<xsl:param name="id" />

		<xsl:comment xml:space="preserve">  [<xsl:value-of select="$id"/>]  </xsl:comment>
	</xsl:template>

	<xsl:template name="getSvgFilename">
		<xsl:param name="id"/>
		<xsl:param name="member"/>

		<xsl:value-of select="concat($id, '_', $member, '.svg')"/>
	</xsl:template>

	<xsl:template name="assertId">
		<xsl:param name="id" />

		<xsl:if test="normalize-space($id) = ''">
			<xsl:message terminate="yes">
				<!--Id is required-->
				<xsl:value-of select="concat('Attribute [Id] does not exist in element [', name(), '].')" />
			</xsl:message>
		</xsl:if>
	</xsl:template>

	<xsl:template name="shouldProcessControl">
		<xsl:param name="control"/>
		<xsl:param name="excludedControls"/>
		<xsl:param name="excludedControlsDelimiter"/>

		<xsl:choose>
			<xsl:when test="$excludedControls">
				<xsl:variable name="lowercaseControl">
					<xsl:call-template name="lowercase">
						<xsl:with-param name="value" select="$control"/>
					</xsl:call-template>
				</xsl:variable>

				<xsl:variable name="lowercaseExcludedControls">
					<xsl:call-template name="split">
						<xsl:with-param name="value" select="$excludedControls"/>
						<xsl:with-param name="delimiter" select="$excludedControlsDelimiter"/>
						<xsl:with-param name="case">lower</xsl:with-param>
					</xsl:call-template>
				</xsl:variable>

				<!--
				We can't simply use msxsl:node-set($lowercaseExcludedControls)/value[. = $lowercaseControl]
				since it doesn't work due to the "custom" default namespace of this transformation.
				-->
				<xsl:value-of select="count(msxsl:node-set($lowercaseExcludedControls)/*[name() = 'value' and . = $lowercaseControl]) = 0" />
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="true()"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template name="generateStyle">
		<xsl:param name="targetType"/>
		<xsl:param name="basedOn"/>
		<xsl:param name="basedOnStaticResource" select="true()"/>
		<xsl:param name="key"/>
		<xsl:param name="setters"/>
		<xsl:param name="triggers"/>

		<xsl:element name="Style">
			<xsl:if test="$targetType">
				<xsl:attribute name="TargetType">
					<xsl:call-template name="generateType">
						<xsl:with-param name="type" select="$targetType"/>
					</xsl:call-template>
				</xsl:attribute>
			</xsl:if>

			<xsl:if test="$basedOn">
				<xsl:attribute name="BasedOn">
					<xsl:choose>
						<xsl:when test="$basedOnStaticResource">
							<xsl:call-template name="generateStaticResource">
								<xsl:with-param name="key" select="$basedOn"/>
							</xsl:call-template>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$basedOn"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:attribute>
			</xsl:if>

			<xsl:if test="$key">
				<xsl:attribute name="x:Key">
					<xsl:value-of select="$key"/>
				</xsl:attribute>
			</xsl:if>

			<xsl:if test="$setters">
				<xsl:copy-of select="$setters"/>
			</xsl:if>

			<xsl:if test="$triggers">
				<xsl:element name="Style.Triggers">
					<xsl:copy-of select="$triggers"/>
				</xsl:element>
			</xsl:if>
		</xsl:element>
	</xsl:template>

	<xsl:template name="generateTrigger">
		<xsl:param name="propertyName"/>
		<xsl:param name="propertyValue"/>
		<xsl:param name="setters"/>

		<xsl:if test="msxsl:node-set($setters)/node()">
			<xsl:element name="Trigger">
				<xsl:attribute name="Property">
					<xsl:value-of select="$propertyName"/>
				</xsl:attribute>

				<xsl:attribute name="Value">
					<xsl:value-of select="$propertyValue"/>
				</xsl:attribute>

				<xsl:copy-of select="$setters"/>
			</xsl:element>
		</xsl:if>
	</xsl:template>

	<xsl:template name="generateDataTrigger">
		<xsl:param name="binding"/>
		<xsl:param name="propertyValue"/>
		<xsl:param name="setters"/>

		<xsl:if test="msxsl:node-set($setters)/node()">
			<xsl:element name="DataTrigger">
				<xsl:attribute name="Binding">
					<xsl:value-of select="$binding"/>
				</xsl:attribute>

				<xsl:attribute name="Value">
					<xsl:value-of select="$propertyValue"/>
				</xsl:attribute>

				<xsl:copy-of select="$setters"/>
			</xsl:element>
		</xsl:if>
	</xsl:template>

	<xsl:template name="generateMultiTrigger">
		<xsl:param name="conditions"/>
		<xsl:param name="setters"/>

		<xsl:if test="msxsl:node-set($setters)/node()">
			<xsl:choose>
				<xsl:when test="msxsl:node-set($conditions)/node()">
				</xsl:when>
				<xsl:otherwise>
					<xsl:message terminate="yes">Unable to generate MultiTrigger since conditions are not set.</xsl:message>
				</xsl:otherwise>
			</xsl:choose>

			<xsl:element name="MultiTrigger">
				<xsl:element name="MultiTrigger.Conditions">
					<xsl:copy-of select="$conditions"/>
				</xsl:element>

				<xsl:if test="$setters">
					<xsl:copy-of select="$setters"/>
				</xsl:if>
			</xsl:element>
		</xsl:if>
	</xsl:template>

	<xsl:template name="generateMultiDataTrigger">
		<xsl:param name="conditions"/>
		<xsl:param name="setters"/>

		<xsl:if test="msxsl:node-set($setters)/node()">
			<xsl:choose>
				<xsl:when test="msxsl:node-set($conditions)/node()">
				</xsl:when>
				<xsl:otherwise>
					<xsl:message terminate="yes">Unable to generate MultiDataTrigger since conditions are not set.</xsl:message>
				</xsl:otherwise>
			</xsl:choose>

			<xsl:element name="MultiDataTrigger">
				<xsl:element name="MultiDataTrigger.Conditions">
					<xsl:copy-of select="$conditions"/>
				</xsl:element>

				<xsl:if test="$setters">
					<xsl:copy-of select="$setters"/>
				</xsl:if>
			</xsl:element>
		</xsl:if>
	</xsl:template>

	<xsl:template name="generateCornerRadiusSetter">
		<xsl:param name="propertyId"/>
		<xsl:param name="cornerRadiusNode" select="CornerRadius"/>
		<xsl:param name="isSingleValueExpected" select="false()"/>

		<xsl:if test="$cornerRadiusNode">
			<xsl:call-template name="generateUiKitSetterViaAttribute">
				<xsl:with-param name="propertyId" select="$propertyId"/>
				<xsl:with-param name="propertyValue">
					<xsl:call-template name="getCornerRadius">
						<xsl:with-param name="topLeft" select="$cornerRadiusNode/@TopLeft"/>
						<xsl:with-param name="topRight" select="$cornerRadiusNode/@TopRight"/>
						<xsl:with-param name="bottomRight" select="$cornerRadiusNode/@BottomRight"/>
						<xsl:with-param name="bottomLeft" select="$cornerRadiusNode/@BottomLeft"/>
						<xsl:with-param name="isSingleValueExpected" select="$isSingleValueExpected"/>
					</xsl:call-template>
				</xsl:with-param>
			</xsl:call-template>
		</xsl:if>
	</xsl:template>

	<xsl:template name="getCornerRadius">
		<xsl:param name="topLeft"/>
		<xsl:param name="topRight"/>
		<xsl:param name="bottomRight"/>
		<xsl:param name="bottomLeft"/>
		<xsl:param name="isSingleValueExpected" select="false()"/>

		<xsl:choose>
			<xsl:when test="$topLeft=$topRight and $bottomRight=$bottomLeft and $bottomRight=$topRight">
				<xsl:value-of select="$topLeft"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:if test="$isSingleValueExpected">
					<xsl:message terminate="yes">
						<xsl:value-of select="concat('Expected single corner radius value, but got [', $topLeft, ', ', $topRight, ', ', $bottomRight, ', ', $bottomLeft, '].')"/>
					</xsl:message>
				</xsl:if>

				<xsl:choose>
					<xsl:when test="not($topLeft or $topRight or $bottomRight or $bottomLeft)">
						<xsl:value-of select="0"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="concat($topLeft, ',', $topRight, ',', $bottomRight, ',', $bottomLeft)"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template name="generateFocusVisualStyleSetter">
		<xsl:param name="propertyId"/>
		<xsl:param name="focusVisualBrush">FocusVisualBrush</xsl:param>
		<xsl:param name="focusNode" select="Focus"/>
		<xsl:param name="scope"/>

		<xsl:if test="$focusNode">
			<xsl:call-template name="generateUiKitSetterViaElement">
				<xsl:with-param name="propertyId" select="$propertyId"/>
				<xsl:with-param name="propertyValue">
					<xsl:call-template name="generateFocusVisual">
						<xsl:with-param name="focusVisualBrush" select="$focusVisualBrush"/>
						<xsl:with-param name="focusNode" select="$focusNode"/>
						<xsl:with-param name="scope" select="$scope"/>
					</xsl:call-template>
				</xsl:with-param>
			</xsl:call-template>
		</xsl:if>
	</xsl:template>

	<xsl:template name="generateFocusVisual">
		<xsl:param name="focusNode" select="Focus"/>
		<xsl:param name="focusVisualBrush">FocusVisualBrush</xsl:param>
		<xsl:param name="scope"/>

		<xsl:element name="visuals:FocusVisual">
			<xsl:attribute name="Brush">
				<xsl:call-template name="generateResExtension">
					<xsl:with-param name="key" select="$focusVisualBrush" />
					<xsl:with-param name="scope" select="$scope" />
				</xsl:call-template>
			</xsl:attribute>

			<xsl:if test="$focusNode/CornerRadius">
				<xsl:attribute name="CornerRadius">
					<xsl:call-template name="getCornerRadius">
						<xsl:with-param name="topLeft" select="$focusNode/CornerRadius/@TopLeft"></xsl:with-param>
						<xsl:with-param name="topRight" select="$focusNode/CornerRadius/@TopRight"></xsl:with-param>
						<xsl:with-param name="bottomRight" select="$focusNode/CornerRadius/@BottomRight"></xsl:with-param>
						<xsl:with-param name="bottomLeft" select="$focusNode/CornerRadius/@BottomLeft"></xsl:with-param>
					</xsl:call-template>
				</xsl:attribute>
			</xsl:if>

			<xsl:if test="$focusNode/Margin/@Left or $focusNode/Margin/@Top or $focusNode/Margin/@Right or $focusNode/Margin/@Bottom">
				<xsl:attribute name="Margin">
					<xsl:call-template name="getThickness">
						<xsl:with-param name="left" select="$focusNode/Margin/@Left" />
						<xsl:with-param name="top" select="$focusNode/Margin/@Top" />
						<xsl:with-param name="right" select="$focusNode/Margin/@Right" />
						<xsl:with-param name="bottom" select="$focusNode/Margin/@Bottom" />
					</xsl:call-template>
				</xsl:attribute>
			</xsl:if>

			<xsl:if test="$focusNode/@Thickness">
				<xsl:attribute name="Thickness">
					<xsl:value-of select="$focusNode/@Thickness" />
				</xsl:attribute>
			</xsl:if>

			<xsl:if test="$focusNode/@Type">
				<xsl:attribute name="Type">
					<xsl:value-of select="$focusNode/@Type" />
				</xsl:attribute>
			</xsl:if>
		</xsl:element>
	</xsl:template>

	<xsl:template name="generateAttributeSetter">
		<xsl:param name="propertyName"/>
		<xsl:param name="propertyValue"/>
		<xsl:param name="allowEmptyValue"/>

		<xsl:if test="$allowEmptyValue or $propertyValue and normalize-space($propertyValue) != ''">
			<xsl:call-template name="generateSetterViaAttribute">
				<xsl:with-param name="propertyName" select="$propertyName"/>
				<xsl:with-param name="propertyValue" select="$propertyValue" />
			</xsl:call-template>
		</xsl:if>
	</xsl:template>

	<xsl:template name="generateImgExtension">
		<xsl:param name="key" />
		<xsl:param name="scope">Svg</xsl:param>
		<xsl:param name="mode">SvgImage</xsl:param>

		<xsl:value-of select="concat('{Img ', $key,', Scope=', $scope, ', Mode=', $mode, '}')" />
	</xsl:template>

	<xsl:template name="generateStaticResource">
		<xsl:param name="key" />

		<xsl:value-of select="concat('{StaticResource ', $key, '}')" />
	</xsl:template>

	<xsl:template name="generateFontStyle">
		<xsl:param name="key" />

		<xsl:value-of select="concat('{visuals:UIKitFontStyle ', $key, '}')" />
	</xsl:template>

	<xsl:template name="generateFontBrush">
		<xsl:param name="key" />

		<xsl:value-of select="concat('{visuals:UIKitBrushStyle ', $key, '}')" />
	</xsl:template>

	<xsl:template name="generateType">
		<xsl:param name="type"/>

		<xsl:value-of select="concat('{x:Type ', $type, '}')"/>
	</xsl:template>

	<xsl:template name="generateResExtension">
		<xsl:param name="key" />
		<xsl:param name="scope" />

		<xsl:value-of select="concat('{Res ', $key,', Scope=', $scope, '}')" />
	</xsl:template>

	<xsl:template name="generateCondition">
		<xsl:param name="binding"/>
		<xsl:param name="propertyName"/>
		<xsl:param name="propertyValue"/>

		<xsl:if test="$binding and $propertyName">
			<xsl:message terminate="yes">Unable to generate Condition since both Binding and PropertyName are set.</xsl:message>
		</xsl:if>

		<xsl:element name="Condition">
			<xsl:if test="$binding">
				<xsl:attribute name="Binding">
					<xsl:value-of select="$binding"/>
				</xsl:attribute>
			</xsl:if>
			<xsl:if test="$propertyName">
				<xsl:attribute name="Property">
					<xsl:value-of select="$propertyName"/>
				</xsl:attribute>
			</xsl:if>
			<xsl:attribute name="Value">
				<xsl:value-of select="$propertyValue"/>
			</xsl:attribute>
		</xsl:element>
	</xsl:template>

	<xsl:template name="generateBinding">
		<xsl:param name="propertyName"/>
		<xsl:param name="path"/>
		<xsl:param name="relativeSource"/>

		<xsl:if test="$propertyName and $path">
			<xsl:message terminate="yes">Unable to generate Binding since both PropertyName and Path are set.</xsl:message>
		</xsl:if>

		<xsl:variable name="pathExpression">
			<xsl:choose>
				<xsl:when test="$path">
					<xsl:choose>
						<xsl:when test="contains($path, ':')">
							<xsl:value-of select="concat('Path=(', $path, ')')"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="concat('Path=', $path)"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:when>
				<xsl:otherwise></xsl:otherwise>
			</xsl:choose>
		</xsl:variable>

		<xsl:variable name="relativeSourceExpression">
			<xsl:choose>
				<xsl:when test="$relativeSource">
					<xsl:value-of select="concat(', RelativeSource=', $relativeSource)"/>
				</xsl:when>
				<xsl:otherwise></xsl:otherwise>
			</xsl:choose>
		</xsl:variable>

		<xsl:value-of select="concat('{Binding ', $propertyName, $pathExpression, $relativeSourceExpression, '}')"/>
	</xsl:template>

	<xsl:template name="generateCompactMultiBinding">
		<xsl:param name="binding1"/>
		<xsl:param name="binding2"/>
		<xsl:param name="binding3"/>
		<xsl:param name="binding4"/>
		<xsl:param name="converter"/>

		<xsl:if test="not($binding1)">
			<xsl:message terminate="yes">Unable to generate CompactMultiBinding since at least Binding1 is not set.</xsl:message>
		</xsl:if>

		<xsl:if test="not($converter)">
			<xsl:message terminate="yes">Unable to generate CompactMultiBinding since Converter is not set.</xsl:message>
		</xsl:if>

		<xsl:variable name="binding1Expression">
			<xsl:choose>
				<xsl:when test="$binding1">
					<xsl:value-of select="concat('Binding1=', $binding1)"/>
				</xsl:when>
				<xsl:otherwise></xsl:otherwise>
			</xsl:choose>
		</xsl:variable>

		<xsl:variable name="binding2Expression">
			<xsl:choose>
				<xsl:when test="$binding2">
					<xsl:value-of select="concat(', Binding2=', $binding2)"/>
				</xsl:when>
				<xsl:otherwise></xsl:otherwise>
			</xsl:choose>
		</xsl:variable>

		<xsl:variable name="binding3Expression">
			<xsl:choose>
				<xsl:when test="$binding3">
					<xsl:value-of select="concat(', Binding3=', $binding3)"/>
				</xsl:when>
				<xsl:otherwise></xsl:otherwise>
			</xsl:choose>
		</xsl:variable>

		<xsl:variable name="binding4Expression">
			<xsl:choose>
				<xsl:when test="$binding4">
					<xsl:value-of select="concat(', Binding4=', $binding4)"/>
				</xsl:when>
				<xsl:otherwise></xsl:otherwise>
			</xsl:choose>
		</xsl:variable>

		<xsl:variable name="converterExpression" select="concat(', Converter=', $converter)"/>

		<xsl:value-of select="concat('{visuals:CompactMultiBinding ', $binding1Expression, $binding2Expression, $binding3Expression, $binding4Expression, $converterExpression, '}')"/>
	</xsl:template>

	<xsl:template name="generateRelativeSource">
		<xsl:param name="mode">Self</xsl:param>
		<xsl:param name="ancestorType"/>

		<xsl:variable name="lowercaseMode">
			<xsl:call-template name="lowercase">
				<xsl:with-param name="value" select="$mode"/>
			</xsl:call-template>
		</xsl:variable>

		<xsl:choose>
			<xsl:when test="$lowercaseMode = 'previousdata'">{RelativeSource PreviousData}</xsl:when>
			<xsl:when test="$lowercaseMode = 'templatedparent'">{RelativeSource TemplatedParent}</xsl:when>
			<xsl:when test="$lowercaseMode = 'self'">{RelativeSource Self}</xsl:when>
			<xsl:when test="$lowercaseMode = 'findancestor'">
				<xsl:choose>
					<xsl:when test="$ancestorType">
					</xsl:when>
					<xsl:otherwise>
						<xsl:message terminate="yes">Unable to generate RelativeSource since AncestorType is not set.</xsl:message>
					</xsl:otherwise>
				</xsl:choose>

				<xsl:value-of select="concat('{RelativeSource AncestorType={x:Type ', $ancestorType, '}}')"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:message terminate="yes">
					<xsl:value-of select="concat('Unable to generate RelativeSource since mode [', $mode, '] is unsupported.')" />
				</xsl:message>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template name="generateSetterViaAttribute">
		<xsl:param name="propertyName" />
		<xsl:param name="propertyValue" />

		<xsl:element name="Setter">
			<xsl:attribute name="Property">
				<xsl:value-of select="$propertyName"/>
			</xsl:attribute>
			<xsl:attribute name="Value">
				<xsl:value-of select="$propertyValue" />
			</xsl:attribute>
		</xsl:element>
	</xsl:template>

	<xsl:template name="generateUiKitSetterViaAttribute">
		<xsl:param name="propertyId" />
		<xsl:param name="propertyValue" />

		<xsl:if test="not($propertyId)">
			<xsl:message terminate="yes">Unable to generate UIKitSetter since property id is not set.</xsl:message>
		</xsl:if>

		<xsl:element name="uikit:UIKitSetter">
			<xsl:attribute name="Id">
				<xsl:value-of select="$propertyId"/>
			</xsl:attribute>
			<xsl:attribute name="Value">
				<xsl:value-of select="$propertyValue" />
			</xsl:attribute>
		</xsl:element>
	</xsl:template>

	<xsl:template name="generateSetterViaElement">
		<xsl:param name="propertyName" />
		<xsl:param name="propertyValue" />

		<xsl:element name="Setter">
			<xsl:attribute name="Property">
				<xsl:value-of select="$propertyName"/>
			</xsl:attribute>
			<xsl:element name="Setter.Value">
				<xsl:copy-of select="$propertyValue" />
			</xsl:element>
		</xsl:element>
	</xsl:template>

	<xsl:template name="generateUiKitSetterViaElement">
		<xsl:param name="propertyId" />
		<xsl:param name="propertyValue" />

		<xsl:element name="uikit:UIKitSetter">
			<xsl:attribute name="Id">
				<xsl:value-of select="$propertyId"/>
			</xsl:attribute>
			<xsl:element name="uikit:UIKitSetter.Value">
				<xsl:copy-of select="$propertyValue" />
			</xsl:element>
		</xsl:element>
	</xsl:template>

	<xsl:template name="generateBrushSetter">
		<xsl:param name="propertyName" />
		<xsl:param name="propertyId" />
		<xsl:param name="brushName" />
		<xsl:param name="scopeName" />

		<xsl:if test="$propertyId and $propertyName">
			<xsl:message terminate="yes">Unable to generate BrushSetter because propertyId and propertyName are set at the same time.</xsl:message>
		</xsl:if>

		<xsl:if test="$propertyId">
			<xsl:call-template name="generateUiKitSetterViaAttribute">
				<xsl:with-param name="propertyId" select="$propertyId" />
				<xsl:with-param name="propertyValue">
					<xsl:call-template name="generateResExtension">
						<xsl:with-param name="key" select="$brushName" />
						<xsl:with-param name="scope" select="$scopeName" />
					</xsl:call-template>
				</xsl:with-param>
			</xsl:call-template>
		</xsl:if>

		<xsl:if test="$propertyName">
			<xsl:call-template name="generateSetterViaAttribute">
				<xsl:with-param name="propertyName" select="$propertyName" />
				<xsl:with-param name="propertyValue">
					<xsl:call-template name="generateResExtension">
						<xsl:with-param name="key" select="$brushName" />
						<xsl:with-param name="scope" select="$scopeName" />
					</xsl:call-template>
				</xsl:with-param>
			</xsl:call-template>
		</xsl:if>
	</xsl:template>

	<xsl:template name="generateThicknessSetter">
		<xsl:param name="propertyId" />
		<xsl:param name="thicknessNode" select="BorderThickness" />

		<xsl:call-template name="generateUiKitSetterViaAttribute">
			<xsl:with-param name="propertyId" select="$propertyId" />
			<xsl:with-param name="propertyValue">
				<xsl:call-template name="generateThickness">
					<xsl:with-param name="node" select="$thicknessNode"/>
				</xsl:call-template>
			</xsl:with-param>
		</xsl:call-template>
	</xsl:template>

	<xsl:template name="generateStaticResourceSetter">
		<xsl:param name="propertyId" />
		<xsl:param name="resourceName" />

		<xsl:call-template name="generateUiKitSetterViaAttribute">
			<xsl:with-param name="propertyId" select="$propertyId" />
			<xsl:with-param name="propertyValue">
				<xsl:call-template name="generateStaticResource">
					<xsl:with-param name="key" select="$resourceName"/>
				</xsl:call-template>
			</xsl:with-param>
		</xsl:call-template>
	</xsl:template>

	<xsl:template name="generateFontStyleSetter">
		<xsl:param name="propertyId" />
		<xsl:param name="resourceName" />

		<xsl:call-template name="generateUiKitSetterViaAttribute">
			<xsl:with-param name="propertyId" select="$propertyId" />
			<xsl:with-param name="propertyValue">
				<xsl:call-template name="generateFontStyle">
					<xsl:with-param name="key" select="$resourceName"/>
				</xsl:call-template>
			</xsl:with-param>
		</xsl:call-template>
	</xsl:template>

	<xsl:template name="generateFontBrushSetter">
		<xsl:param name="propertyId" />
		<xsl:param name="resourceName" />

		<xsl:call-template name="generateUiKitSetterViaAttribute">
			<xsl:with-param name="propertyId" select="$propertyId" />
			<xsl:with-param name="propertyValue">
				<xsl:call-template name="generateFontBrush">
					<xsl:with-param name="key" select="$resourceName"/>
				</xsl:call-template>
			</xsl:with-param>
		</xsl:call-template>
	</xsl:template>

	<xsl:template name="generateShadowEffectFromShadowElement">
		<xsl:param name="key">Shadow</xsl:param>
		<xsl:param name="shadowNode" select="Shadow"/>

		<!--Ensure node has at least one attribute-->
		<xsl:if test="$shadowNode and count($shadowNode/@*) > 0">
			<xsl:call-template name="generateShadowEffect">
				<xsl:with-param name="key" select="$key" />
				<xsl:with-param name="blurRadius" select="$shadowNode/@BlurRadius" />
				<xsl:with-param name="color">
					<xsl:call-template name="convertRgbaToRgb">
						<xsl:with-param name="rgba" select="$shadowNode/@Color" />
					</xsl:call-template>
				</xsl:with-param>
				<xsl:with-param name="depth" select="$shadowNode/@Depth" />
				<xsl:with-param name="direction" select="$shadowNode/@Direction" />
				<xsl:with-param name="opacity">
					<xsl:call-template name="convertRgbaToOpacity">
						<xsl:with-param name="rgba" select="$shadowNode/@Color" />
					</xsl:call-template>
				</xsl:with-param>
			</xsl:call-template>
		</xsl:if>
	</xsl:template>

	<xsl:template name="generateShadowEffect">
		<xsl:param name="key" />
		<xsl:param name="blurRadius" />
		<xsl:param name="color" />
		<xsl:param name="depth" />
		<xsl:param name="direction" />
		<xsl:param name="opacity" />

		<xsl:element name="DropShadowEffect">
			<xsl:attribute name="x:Key">
				<xsl:value-of select="$key"/>
			</xsl:attribute>

			<xsl:if test="$blurRadius">
				<xsl:attribute name="BlurRadius">
					<xsl:value-of select="$blurRadius" />
				</xsl:attribute>
			</xsl:if>

			<xsl:if test="$color != ''">
				<xsl:attribute name="Color">
					<xsl:value-of select="$color" />
				</xsl:attribute>
			</xsl:if>

			<xsl:if test="$direction">
				<xsl:attribute name="Direction">
					<xsl:value-of select="$direction" />
				</xsl:attribute>
			</xsl:if>

			<xsl:if test="$depth">
				<xsl:attribute name="ShadowDepth">
					<xsl:value-of select="$depth" />
				</xsl:attribute>
			</xsl:if>

			<xsl:if test="$opacity">
				<xsl:attribute name="Opacity">
					<xsl:value-of select="$opacity" />
				</xsl:attribute>
			</xsl:if>

		</xsl:element>
	</xsl:template>

	<xsl:template name="generateShadowSetter">
		<xsl:param name="propertyId">Container_Shadow</xsl:param>
		<xsl:param name="shadowNode" select="Shadow"/>
		<xsl:param name="scope"/>

		<!--Ensure node has at least one attribute-->
		<xsl:if test="$shadowNode and count($shadowNode/@*) > 0">
			<xsl:call-template name="generateUiKitSetterViaAttribute">
				<xsl:with-param name="propertyId" select="$propertyId"/>
				<xsl:with-param name="propertyValue">
					<xsl:call-template name="generateResExtension">
						<!--Get name of node for key parameter-->
						<xsl:with-param name="key" select="name($shadowNode)"/>
						<xsl:with-param name="scope" select="$scope" />
					</xsl:call-template>
				</xsl:with-param>
			</xsl:call-template>
		</xsl:if>
	</xsl:template>

	<xsl:template name="generateMarginSetter">
		<xsl:param name="propertyId"/>
		<xsl:param name="marginNode" select="Margin"/>

		<xsl:if test="$marginNode/@Left or $marginNode/@Right or $marginNode/@Top or $marginNode/@Bottom">
			<xsl:call-template name="generateUiKitSetterViaAttribute">
				<xsl:with-param name="propertyId" select="$propertyId" />
				<xsl:with-param name="propertyValue">
					<xsl:call-template name="getThickness">
						<xsl:with-param name="left" select="$marginNode/@Left" />
						<xsl:with-param name="top" select="$marginNode/@Top" />
						<xsl:with-param name="right" select="$marginNode/@Right" />
						<xsl:with-param name="bottom" select="$marginNode/@Bottom" />
					</xsl:call-template>
				</xsl:with-param>
			</xsl:call-template>
		</xsl:if>
	</xsl:template>

	<xsl:template name="generatePaddingSetter">
		<xsl:param name="propertyId"/>
		<xsl:param name="paddingNode" select="Padding"/>

		<xsl:if test="$paddingNode/@Left or $paddingNode/@Right or $paddingNode/@Top or $paddingNode/@Bottom">
			<xsl:call-template name="generateUiKitSetterViaAttribute">
				<xsl:with-param name="propertyId" select="$propertyId" />
				<xsl:with-param name="propertyValue">
					<xsl:call-template name="getThickness">
						<xsl:with-param name="left" select="$paddingNode/@Left" />
						<xsl:with-param name="top" select="$paddingNode/@Top" />
						<xsl:with-param name="right" select="$paddingNode/@Right" />
						<xsl:with-param name="bottom" select="$paddingNode/@Bottom" />
					</xsl:call-template>
				</xsl:with-param>
			</xsl:call-template>
		</xsl:if>
	</xsl:template>

	<xsl:template name="generateHorizontalContentAlignmentSetter">
		<xsl:if test="@HorizontalContentAlignment">
			<xsl:call-template name="generateSetterViaAttribute">
				<xsl:with-param name="propertyName">HorizontalContentAlignment</xsl:with-param>
				<xsl:with-param name="propertyValue" select="@HorizontalContentAlignment" />
			</xsl:call-template>
		</xsl:if>
	</xsl:template>

	<xsl:template name="generateVerticalContentAlignmentSetter">
		<xsl:if test="@VerticalContentAlignment">
			<xsl:call-template name="generateSetterViaAttribute">
				<xsl:with-param name="propertyName">VerticalContentAlignment</xsl:with-param>
				<xsl:with-param name="propertyValue" select="@VerticalContentAlignment" />
			</xsl:call-template>
		</xsl:if>
	</xsl:template>

	<xsl:template name="generateHeightSetter">
		<xsl:param name="propertyId"/>
		<xsl:param name="heightNode" select="@Height"/>

		<xsl:if test="$heightNode">
			<xsl:call-template name="generateUiKitSetterViaAttribute">
				<xsl:with-param name="propertyId" select="$propertyId" />
				<xsl:with-param name="propertyValue" select="$heightNode" />
			</xsl:call-template>
		</xsl:if>
	</xsl:template>

	<xsl:template name="generateWidthSetter">
		<xsl:param name="propertyId"/>
		<xsl:param name="widthNode" select="@Width"/>

		<xsl:call-template name="generateUiKitSetterViaAttribute">
			<xsl:with-param name="propertyId" select="$propertyId" />
			<xsl:with-param name="propertyValue">
				<xsl:choose>
					<xsl:when test="$widthNode">
						<xsl:value-of select="$widthNode"/>
					</xsl:when>
					<xsl:otherwise>Auto</xsl:otherwise>
				</xsl:choose>
			</xsl:with-param>
		</xsl:call-template>
	</xsl:template>

	<xsl:template name="convertRgbaToArgb">
		<xsl:param name="rgba" />

		<xsl:choose>
			<xsl:when test="$rgba">
				<xsl:value-of select="concat('#', substring($rgba, 8, 2), substring($rgba, 2, 6))"/>
			</xsl:when>
			<xsl:otherwise></xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template name="convertRgbaToRgb">
		<xsl:param name="rgba" />

		<xsl:choose>
			<xsl:when test="$rgba">
				<xsl:value-of select="concat('#', substring($rgba, 2, 6))"/>
			</xsl:when>
			<xsl:otherwise></xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template name="convertRgbaToOpacity">
		<xsl:param name="rgba" />

		<xsl:choose>
			<xsl:when test="$rgba">
				<xsl:variable name="alphaHex" select="substring($rgba, 8, 2)"/>

				<xsl:variable name="firstDigitHex">
					<xsl:call-template name="uppercase">
						<xsl:with-param name="value" select="substring($alphaHex, 1, 1)"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:variable name="firstDigit" select="string-length(substring-before('0123456789ABCDEF', $firstDigitHex))"/>

				<xsl:variable name="secondDigitHex">
					<xsl:call-template name="uppercase">
						<xsl:with-param name="value" select="substring($alphaHex, 2, 1)"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:variable name="secondDigit" select="string-length(substring-before('0123456789ABCDEF', $secondDigitHex))"/>

				<xsl:variable name="alpha" select="16 * $firstDigit + $secondDigit"/>

				<xsl:value-of select="format-number($alpha div 255, '0.0#')"/>
			</xsl:when>
			<xsl:otherwise>0</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template match="text()" name="replace">
		<xsl:param name="value" />
		<xsl:param name="old" />
		<xsl:param name="new" />
		<xsl:choose>
			<xsl:when test="$value = '' or $old = '' or not($old)" >
				<xsl:value-of select="$value" />
			</xsl:when>

			<xsl:when test="contains($value, $old)">
				<xsl:value-of select="substring-before($value, $old)" />
				<xsl:value-of select="$new" />

				<xsl:call-template name="replace">
					<xsl:with-param name="value" select="substring-after($value, $old)" />
					<xsl:with-param name="old" select="$old" />
					<xsl:with-param name="new" select="$new" />
				</xsl:call-template>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$value" />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template match="text()" name="split">
		<xsl:param name="value"/>
		<xsl:param name="delimiter"/>
		<xsl:param name="case"/>

		<xsl:if test="string-length($value)">
			<xsl:if test="string-length($delimiter) = 0">
				<xsl:message terminate="yes">Unable to split text since delimiter is not set.</xsl:message>
			</xsl:if>

			<xsl:choose>
				<xsl:when test="contains($value, $delimiter)">
					<xsl:variable name="current" select="substring-before($value, $delimiter)"/>
					<xsl:variable name="next" select="substring-after($value, $delimiter)"/>

					<xsl:element name="value">
						<xsl:choose>
							<xsl:when test="$case = 'lower'">
								<xsl:call-template name="lowercase">
									<xsl:with-param name="value" select="$current"/>
								</xsl:call-template>
							</xsl:when>
							<xsl:when test="$case = 'upper'">
								<xsl:call-template name="uppercase">
									<xsl:with-param name="value" select="$current"/>
								</xsl:call-template>
							</xsl:when>
							<xsl:otherwise>
								<xsl:value-of select="$current"/>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:element>

					<xsl:call-template name="split">
						<xsl:with-param name="value" select="$next"/>
						<xsl:with-param name="delimiter" select="$delimiter"/>
						<xsl:with-param name="case" select="$case"/>
					</xsl:call-template>
				</xsl:when>
				<xsl:otherwise>
					<xsl:element name="value">
						<xsl:choose>
							<xsl:when test="$case = 'lower'">
								<xsl:call-template name="lowercase">
									<xsl:with-param name="value" select="$value"/>
								</xsl:call-template>
							</xsl:when>
							<xsl:when test="$case = 'upper'">
								<xsl:call-template name="uppercase">
									<xsl:with-param name="value" select="$value"/>
								</xsl:call-template>
							</xsl:when>
							<xsl:otherwise>
								<xsl:value-of select="$value"/>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:element>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:if>
	</xsl:template>

	<xsl:template name="lowercase">
		<xsl:param name="value"/>

		<xsl:value-of select="translate($value, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz')"/>
	</xsl:template>

	<xsl:template name="uppercase">
		<xsl:param name="value"/>

		<xsl:value-of select="translate($value, 'abcdefghijklmnopqrstuvwxyz', 'ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
	</xsl:template>

	<xsl:template name="convertSolidBrushToArgb">
		<xsl:param name="solidBrush" />

		<xsl:choose>
			<xsl:when test="$solidBrush/@Color">
				<xsl:variable name="alpha">
					<xsl:call-template name="componentToHex">
						<xsl:with-param name="component" select="$solidBrush/@Opacity" />
						<xsl:with-param name="default">1</xsl:with-param>
					</xsl:call-template>
				</xsl:variable>

				<xsl:variable name="rgb">
					<xsl:value-of select="substring($solidBrush/@Color, 2, 6)" />
				</xsl:variable>

				<xsl:value-of select="concat('#', $alpha, $rgb)" />
			</xsl:when>
			<xsl:otherwise></xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template name="generateTextDecorationsSetter">
		<xsl:param name="value"/>
		<xsl:param name="propertyId"/>
		<xsl:param name="key">TextDecorations</xsl:param>
		<xsl:param name="scope"/>
		<xsl:param name="ignoreNoneValue">true</xsl:param>

		<xsl:if test="$value and (not($ignoreNoneValue) or normalize-space($value) != 'NONE')">
			<xsl:call-template name="generateUiKitSetterViaAttribute">
				<xsl:with-param name="propertyId" select="$propertyId"/>
				<xsl:with-param name="propertyValue">
					<xsl:call-template name="generateResExtension">
						<xsl:with-param name="key" select="$key"/>
						<xsl:with-param name="scope" select="$scope"/>
					</xsl:call-template>
				</xsl:with-param>
			</xsl:call-template>
		</xsl:if>
	</xsl:template>

	<xsl:template name="generateTextDecorationsWpfSetter">
		<xsl:param name="value"/>
		<xsl:param name="propertyName">TextDecorations</xsl:param>
		<xsl:param name="key">TextDecorations</xsl:param>
		<xsl:param name="scope"/>
		<xsl:param name="ignoreNoneValue">true</xsl:param>

		<xsl:if test="$value and (not($ignoreNoneValue) or normalize-space($value) != 'NONE')">
			<xsl:call-template name="generateSetterViaAttribute">
				<xsl:with-param name="propertyName" select="$propertyName"/>
				<xsl:with-param name="propertyValue">
					<xsl:call-template name="generateResExtension">
						<xsl:with-param name="key" select="$key"/>
						<xsl:with-param name="scope" select="$scope"/>
					</xsl:call-template>
				</xsl:with-param>
			</xsl:call-template>
		</xsl:if>
	</xsl:template>

	<xsl:template name="generateTextDecorationCollection">
		<xsl:param name="key" />
		<xsl:param name="value" />
		<xsl:param name="penOffset" />
		<xsl:param name="ignoreNoneValue">true</xsl:param>

		<xsl:if test="not($ignoreNoneValue) or normalize-space($value) != 'NONE'">
			<xsl:element name="TextDecorationCollection">
				<xsl:attribute name="x:Key">
					<xsl:value-of select="$key"/>
				</xsl:attribute>

				<xsl:if test="normalize-space($value) != 'NONE'">
					<xsl:element name="TextDecoration">
						<xsl:attribute name="Location">
							<xsl:value-of select="$value"/>
						</xsl:attribute>
						<xsl:attribute name="PenOffset">
							<xsl:value-of select="$penOffset"/>
						</xsl:attribute>
					</xsl:element>
				</xsl:if>
			</xsl:element>
		</xsl:if>
	</xsl:template>

	<xsl:template name="generateColor">
		<xsl:param name="key" />
		<xsl:param name="value" />

		<xsl:element name="Color">
			<xsl:attribute name="x:Key">
				<xsl:value-of select="$key"/>
			</xsl:attribute>
			<xsl:value-of select="$value" />
		</xsl:element>
	</xsl:template>

	<xsl:template name="generateBrush">
		<xsl:param name="key" />
		<xsl:param name="brushNode" />

		<xsl:variable name="brushType" select="$brushNode/*/@Type"/>

		<xsl:choose>
			<xsl:when test="$brushType = 'SOLID'">
				<xsl:choose>
					<xsl:when test="$brushNode/SolidBrush/@PaletteStyleId">
						<xsl:call-template name="generatePaletteSolidColorBrush">
							<xsl:with-param name="key" select="$key" />
							<xsl:with-param name="paletteStyleId" select="$brushNode/SolidBrush/@PaletteStyleId" />
						</xsl:call-template>
					</xsl:when>
					<xsl:otherwise>
						<xsl:call-template name="generateSolidColorBrush">
							<xsl:with-param name="key" select="$key" />
							<xsl:with-param name="value" select="$brushNode/SolidBrush/@Color" />
							<xsl:with-param name="opacity" select="$brushNode/SolidBrush/@Opacity" />
						</xsl:call-template>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:otherwise>
				<xsl:choose>
					<xsl:when test="$brushType = 'GRADIENT_LINEAR'">
						<xsl:call-template name="generateLinearGradientBrush">
							<xsl:with-param name="key" select="$key" />
							<xsl:with-param name="gradientBrushNode" select="$brushNode/GradientBrush" />
						</xsl:call-template>
					</xsl:when>
					<xsl:otherwise>
						<xsl:message terminate="yes">
							<xsl:value-of select="concat('Unsupported brush type - [', $brushType, '].')" />
						</xsl:message>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template name="generatePaletteSolidColorBrush">
		<xsl:param name="key" />
		<xsl:param name="paletteStyleId" />

		<xsl:call-template name="generateSolidColorBrush">
			<xsl:with-param name="key" select="$key"/>
			<xsl:with-param name="value">
				<xsl:call-template name="generateResExtension">
					<xsl:with-param name="key" select="$paletteStyleId"/>
					<xsl:with-param name="scope">Palette</xsl:with-param>
				</xsl:call-template>
			</xsl:with-param>
		</xsl:call-template>
	</xsl:template>

	<xsl:template name="generateSolidColorBrush">
		<xsl:param name="key" />
		<xsl:param name="value" />
		<xsl:param name="opacity" />

		<xsl:element name="SolidColorBrush">
			<xsl:attribute name="x:Key">
				<xsl:value-of select="$key"/>
			</xsl:attribute>
			<xsl:if test="$value">
				<xsl:attribute name="Color">
					<xsl:value-of select="$value"/>
				</xsl:attribute>
			</xsl:if>
			<xsl:if test="$opacity">
				<xsl:attribute name="Opacity">
					<xsl:value-of select="$opacity"/>
				</xsl:attribute>
			</xsl:if>
		</xsl:element>
	</xsl:template>

	<xsl:template name="generateLinearGradientBrush">
		<xsl:param name="key" />
		<xsl:param name="gradientBrushNode" />

		<xsl:element name="LinearGradientBrush">
			<xsl:attribute name="x:Key">
				<xsl:value-of select="$key"/>
			</xsl:attribute>

			<xsl:attribute name="StartPoint">
				<xsl:value-of select="$gradientBrushNode/StartPoint/@x"/>,<xsl:value-of select="$gradientBrushNode/StartPoint/@y"/>
			</xsl:attribute>
			<xsl:attribute name="EndPoint">
				<xsl:value-of select="$gradientBrushNode/EndPoint/@x"/>,<xsl:value-of select="$gradientBrushNode/EndPoint/@y"/>
			</xsl:attribute>

			<xsl:for-each select="$gradientBrushNode/GradientStops/GradientStop">
				<xsl:element name="GradientStop">
					<xsl:attribute name="Color">
						<xsl:call-template name="convertRgbaToArgb">
							<xsl:with-param name="rgba" select="Color/SolidBrush/@Color" />
						</xsl:call-template>
					</xsl:attribute>
					<xsl:attribute name="Offset">
						<xsl:value-of select="@Position"/>
					</xsl:attribute>
				</xsl:element>
			</xsl:for-each>
		</xsl:element>
	</xsl:template>

	<xsl:template name="generateThickness">
		<xsl:param name="node" />
		<xsl:call-template name="getThickness">
			<xsl:with-param name="left" select="$node/@Left" />
			<xsl:with-param name="top" select="$node/@Top" />
			<xsl:with-param name="right" select="$node/@Right" />
			<xsl:with-param name="bottom" select="$node/@Bottom" />
		</xsl:call-template>
	</xsl:template>

	<xsl:template name="getThickness">
		<xsl:param name="left" />
		<xsl:param name="top" />
		<xsl:param name="right" />
		<xsl:param name="bottom" />

		<xsl:variable name="resolvedLeft">
			<xsl:call-template name="resolveNumber">
				<xsl:with-param name="number" select="$left" />
			</xsl:call-template>
		</xsl:variable>
		<xsl:variable name="resolvedTop">
			<xsl:call-template name="resolveNumber">
				<xsl:with-param name="number" select="$top" />
			</xsl:call-template>
		</xsl:variable>
		<xsl:variable name="resolvedRight">
			<xsl:call-template name="resolveNumber">
				<xsl:with-param name="number" select="$right" />
			</xsl:call-template>
		</xsl:variable>
		<xsl:variable name="resolvedBottom">
			<xsl:call-template name="resolveNumber">
				<xsl:with-param name="number" select="$bottom" />
			</xsl:call-template>
		</xsl:variable>

		<xsl:choose>
			<xsl:when test="$resolvedLeft = $resolvedTop and $resolvedTop = $resolvedRight and $resolvedRight = $resolvedBottom">
				<xsl:call-template name="getOneComponentThickness">
					<xsl:with-param name="thickness" select="$resolvedLeft" />
				</xsl:call-template>
			</xsl:when>
			<xsl:otherwise>
				<xsl:choose>
					<xsl:when test="$resolvedLeft = $resolvedRight and $resolvedTop = $resolvedBottom">
						<xsl:call-template name="getTwoComponentThickness">
							<xsl:with-param name="horizontal" select="$resolvedLeft" />
							<xsl:with-param name="vertical" select="$resolvedTop" />
						</xsl:call-template>
					</xsl:when>
					<xsl:otherwise>
						<xsl:call-template name="getFourComponentThickness">
							<xsl:with-param name="left" select="$resolvedLeft" />
							<xsl:with-param name="top" select="$resolvedTop" />
							<xsl:with-param name="right" select="$resolvedRight" />
							<xsl:with-param name="bottom" select="$resolvedBottom" />
						</xsl:call-template>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template name="getOneComponentThickness">
		<xsl:param name="thickness" />
		<xsl:value-of select="$thickness" />
	</xsl:template>

	<xsl:template name="getTwoComponentThickness">
		<xsl:param name="horizontal" />
		<xsl:param name="vertical" />
		<xsl:value-of select="$horizontal" />,<xsl:value-of select="$vertical" />
	</xsl:template>

	<xsl:template name="getFourComponentThickness">
		<xsl:param name="left" />
		<xsl:param name="top" />
		<xsl:param name="right" />
		<xsl:param name="bottom" />
		<xsl:value-of select="$left" />,<xsl:value-of select="$top" />,<xsl:value-of select="$right" />,<xsl:value-of select="$bottom" />
	</xsl:template>

	<xsl:template name="resolveValue">
		<xsl:param name="value"/>
		<xsl:param name="defaultValue"/>

		<xsl:choose>
			<xsl:when test="$value">
				<xsl:value-of select="$value"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$defaultValue"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template name="resolveNumber">
		<xsl:param name="number" />
		<xsl:variable name="resolvedNumber">
			<xsl:choose>
				<xsl:when test="$number">
					<xsl:value-of select="$number"/>
				</xsl:when>
				<xsl:otherwise>0</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>

		<xsl:value-of select="$resolvedNumber" />
	</xsl:template>

	<xsl:template name="componentToHex">
		<xsl:param name="component" />
		<xsl:param name="default">0</xsl:param>

		<xsl:variable name="resolvedComponent">
			<xsl:choose>
				<xsl:when test="$component">
					<xsl:value-of select="$component" />
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$default" />
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>

		<xsl:choose>
			<xsl:when test="$component &lt; 0 or $component &gt; 1">
				<xsl:message terminate="yes">
					<xsl:value-of select="concat('Invalid component value [', $component, ']. Value should be from [0, 1].')" />
				</xsl:message>
			</xsl:when>
		</xsl:choose>

		<xsl:variable name="scaledComponent">
			<xsl:value-of select="round($component * 255)" />
		</xsl:variable>

		<xsl:variable name="hex">
			<xsl:call-template name="convertToHex">
				<xsl:with-param name="number" select="$scaledComponent" />
			</xsl:call-template>
		</xsl:variable>

		<xsl:choose>
			<xsl:when test="string-length($hex) = 2">
				<xsl:value-of select="$hex" />
			</xsl:when>
			<xsl:otherwise>
				<xsl:variable name="leadingZeros">
					<xsl:call-template name="repeat">
						<xsl:with-param name="value">0</xsl:with-param>
						<xsl:with-param name="count" select="2 - string-length($hex)" />
					</xsl:call-template>
				</xsl:variable>

				<xsl:value-of select="concat($leadingZeros, $hex)" />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template name="convertToHex">
		<xsl:param name="number" />

		<xsl:if test="$number &lt; 0">
			<xsl:message terminate="yes">
				<xsl:value-of select="concat('Invalid value [', $number, '] for converting to hex. Negative values are not supported.')" />
			</xsl:message>
		</xsl:if>

		<xsl:if test="$number > 0">
			<xsl:call-template name="convertToHex">
				<xsl:with-param name="number" select="floor($number div 16)" />
			</xsl:call-template>
			<xsl:choose>
				<xsl:when test="$number mod 16 &lt; 10">
					<xsl:value-of select="$number mod 16" />
				</xsl:when>
				<xsl:otherwise>
					<xsl:choose>
						<xsl:when test="$number mod 16 = 10">a</xsl:when>
						<xsl:when test="$number mod 16 = 11">b</xsl:when>
						<xsl:when test="$number mod 16 = 12">c</xsl:when>
						<xsl:when test="$number mod 16 = 13">d</xsl:when>
						<xsl:when test="$number mod 16 = 14">e</xsl:when>
						<xsl:when test="$number mod 16 = 15">f</xsl:when>
						<xsl:otherwise>a</xsl:otherwise>
					</xsl:choose>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:if>
	</xsl:template>

	<xsl:template name="repeat">
		<xsl:param name="value" />
		<xsl:param name="count" />

		<xsl:if test="$count > 0">
			<xsl:value-of select="$value" />
			<xsl:call-template name="repeat">
				<xsl:with-param name="value" select="$value" />
				<xsl:with-param name="count" select="$count - 1" />
			</xsl:call-template>
		</xsl:if>
	</xsl:template>

	<xsl:template name="generateFontSetters">
		<xsl:param name="fontFamilyPropertyName">FontFamily</xsl:param>
		<xsl:param name="fontSizePropertyName">FontSize</xsl:param>
		<xsl:param name="fontStylePropertyName">FontStyle</xsl:param>
		<xsl:param name="fontWeightPropertyName">FontWeight</xsl:param>
		<xsl:param name="fontNode" select="Font"/>

		<!--FontFamily-->
		<xsl:if test="$fontNode/@FontFamily and normalize-space($fontNode/@FontFamily) != ''">
			<xsl:call-template name="generateAttributeSetter">
				<xsl:with-param name="propertyName" select="$fontFamilyPropertyName"/>
				<xsl:with-param name="propertyValue">
					<xsl:call-template name="generateResExtension">
						<xsl:with-param name="key" select="concat(translate($fontNode/@FontFamily, ' ', ''), 'FontFamily')" />
						<xsl:with-param name="scope">Fonts</xsl:with-param>
					</xsl:call-template>
				</xsl:with-param>
			</xsl:call-template>
		</xsl:if>

		<!--FontSize-->
		<xsl:if test="$fontNode/@FontSize">
			<xsl:call-template name="generateAttributeSetter">
				<xsl:with-param name="propertyName" select="$fontSizePropertyName"/>
				<xsl:with-param name="propertyValue" select="$fontNode/@FontSize"/>
			</xsl:call-template>
		</xsl:if>

		<!--FontStyle-->
		<xsl:if test="$fontNode/@FontStyle">
			<xsl:call-template name="generateAttributeSetter">
				<xsl:with-param name="propertyName" select="$fontStylePropertyName"/>
				<xsl:with-param name="propertyValue" select="$fontNode/@FontStyle"/>
			</xsl:call-template>
		</xsl:if>

		<!--FontWeight-->
		<xsl:if test="$fontNode/@FontWeight">
			<xsl:call-template name="generateAttributeSetter">
				<xsl:with-param name="propertyName" select="$fontWeightPropertyName"/>
				<xsl:with-param name="propertyValue" select="$fontNode/@FontWeight"/>
			</xsl:call-template>
		</xsl:if>
	</xsl:template>

</xsl:transform>